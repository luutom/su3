(* ::Package:: *)

(* ::Subsection::Closed:: *)
(*Gell-Mann matrices*)


(* ::Input:: *)
(*Clear[GellMann]*)
(*GellMann[n_]:=GellMann[n]=Flatten[Table[(*Symmetric case*)SparseArray[{{j,k}->1,{k,j}->1},{n,n}],{k,2,n},{j,1,k-1}],1]~Join~Flatten[Table[(*Antisymmetric case*)SparseArray[{{j,k}->-I,{k,j}->+I},{n,n}],{k,2,n},{j,1,k-1}],1]~Join~Table[(*Diagonal case*)Sqrt[2/l/(l+1)] SparseArray[Table[{j,j}->1,{j,1,l}]~Join~{{l+1,l+1}->-l},{n,n}],{l,1,n-1}]*)


(* ::Input:: *)
(*MatrixForm/@GellMann[3]*)


(* ::Input:: *)
(*\[Lambda][1]=GellMann[3][[1]];*)
(*\[Lambda][2]=GellMann[3][[4]];*)
(*\[Lambda][3]=GellMann[3][[7]];*)
(*\[Lambda][4]=GellMann[3][[2]];*)
(*\[Lambda][5]=GellMann[3][[5]];*)
(*\[Lambda][6]=GellMann[3][[3]];*)
(*\[Lambda][7]=GellMann[3][[6]];*)
(*\[Lambda][8]=GellMann[3][[8]];*)


(* ::Input:: *)
(*T[1]=1/2 \[Lambda][1];*)
(*T[2]=1/2 \[Lambda][2];*)
(*T[3]=1/2 \[Lambda][3];*)
(*T[4]=1/2 \[Lambda][4];*)
(*T[5]=1/2 \[Lambda][5];*)
(*T[6]=1/2 \[Lambda][6];*)
(*T[7]=1/2 \[Lambda][7];*)
(*T[8]=1/2 \[Lambda][8];*)


(* ::Input:: *)
(*Iplus=(T[1]+I T[2]);*)
(*Iminus=(T[1]-I T[2]);*)
(*Vplus=(T[4]+I T[5]);*)
(*Vminus=(T[4]-I T[5]);*)
(*Uplus=(T[6]+I T[7]);*)
(*Uminus=(T[6]-I T[7]);*)


(* ::Subsection::Closed:: *)
(*Functions*)


(* ::Text:: *)
(*Basis routines:*)


(* ::Input:: *)
(*makeVect[n3s_,n3bs_,coeff_]:=Module[{basis},*)
(*basis={};*)
(*If[n3s==1 && n3bs==0,*)
(*Do[AppendTo[basis,{{i},{},coeff}],{i,1,3}];*)
(*];*)
(*If[n3s==2 && n3bs==0,*)
(*Do[AppendTo[basis,{{i,j},{},coeff}],{i,1,3},{j,1,3}];*)
(*];*)
(*If[n3bs==1 && n3s==0,*)
(*Do[AppendTo[basis,{{},{i},coeff}],{i,1,3}];*)
(*];*)
(*If[n3s==0 && n3bs==2,*)
(*Do[AppendTo[basis,{{},{i,j},coeff}],{i,1,3},{j,1,3}];*)
(*];*)
(*If[n3bs==1 && n3s==1,*)
(*Do[Do[AppendTo[basis,{{j},{i},coeff}],{j,1,3}],{i,1,3}];*)
(*];*)
(*If[n3s==2 && n3bs==1,*)
(*Do[Do[Do[AppendTo[basis,{{j,k},{i},coeff}],{k,1,3}],{j,1,3}],{i,1,3}];*)
(*];*)
(*If[n3s==1 && n3bs==2,*)
(*Do[Do[Do[AppendTo[basis,{{j},{i,k},coeff}],{k,1,3}],{j,1,3}],{i,1,3}];*)
(*];*)
(*(* need general routine!!! *)*)
(*Return[basis];*)
(*];*)


(* ::Input:: *)
(*printComponent[ten_]:=Module[{coeff,n3s,n3bs},*)
(*If[(coeff=ten[[3]])==0,Return[]];*)
(*{n3s,n3bs}={Dimensions[ten[[1]]][[1]],Dimensions[ten[[2]]][[1]]};*)
(*If[coeff==0,Return[]];*)
(*If[n3s==1 && n3bs==0,*)
(*Print["|",ten[[1,1]],"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==2 && n3bs==0,*)
(*Print["|",ten[[1,1]],ten[[1,2]],"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==0 && n3bs==1,*)
(*Print["|",\!\(\*OverscriptBox[\(ten[\([\)\(2, 1\)\(]\)]\), \(_\)]\),"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==0 && n3bs==2,*)
(*Print["|",\!\(\*OverscriptBox[\(ten[\([\)\(2, 1\)\(]\)]\), \(_\)]\),\!\(\*OverscriptBox[\(ten[\([\)\(2, 2\)\(]\)]\), \(_\)]\),"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==1 && n3bs==1,*)
(*Print["|",ten[[1,1]],"\[RightAngleBracket]\[CenterDot]|",\!\(\*OverscriptBox[\(ten[\([\)\(2, 1\)\(]\)]\), \(_\)]\),"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==2 && n3bs==1,*)
(*Print["|",ten[[1,1]],ten[[1,2]],"\[RightAngleBracket]\[CenterDot]|",\!\(\*OverscriptBox[\(ten[\([\)\(2, 1\)\(]\)]\), \(_\)]\),"\[RightAngleBracket] ",coeff]];*)
(*If[n3s==1 && n3bs==2,*)
(*Print["|",ten[[1,1]],"\[RightAngleBracket]\[CenterDot]|",\!\(\*OverscriptBox[\(ten[\([\)\(2, 1\)\(]\)]\), \(_\)]\),\!\(\*OverscriptBox[\(ten[\([\)\(2, 2\)\(]\)]\), \(_\)]\),"\[RightAngleBracket] ",coeff]];*)
(*(* need general routine *)*)
(*];*)


(* ::Input:: *)
(*printVect[ten_]:=Module[{coeff,n3s,n3bs},*)
(*Do[*)
(*printComponent[ten[[i]]],*)
(*{i,1,Length[ten]}*)
(*];*)
(*];*)


(* ::Input:: *)
(*sumVect[ten1_,ten2_]:=Module[{coeff,n3s,n3bs,ten12},*)
(*ten12=ten1;*)
(*Do[*)
(*ten12[[i]][[3]]+=ten2[[i]][[3]],*)
(*{i,1,Length[ten1]}*)
(*];*)
(*Return[ten12];*)
(*];*)


(* ::Input:: *)
(*diffVect[ten1_,ten2_]:=Module[{coeff,n3s,n3bs,ten12},*)
(*ten12=ten1;*)
(*Do[*)
(*ten12[[i]][[3]]-=ten2[[i]][[3]],*)
(*{i,1,Length[ten1]}*)
(*];*)
(*Return[ten12];*)
(*];*)


(* ::Input:: *)
(*dotVect[ten1_,ten2_]:=Module[{answer},*)
(*answer=0;*)
(*Do[*)
(*answer+=Conjugate[ten1[[i]][[3]]  ten2[[i]][[3]]],*)
(*{i,1,Length[ten1]}*)
(*];*)
(*Return[answer];*)
(*];*)


(* ::Input:: *)
(*(*printVect[makeVect[2,1,.5]]*)*)


(* ::Text:: *)
(*transformation routines:*)


(* ::Input:: *)
(*findComponent[lten_,uten_,vect_]:=Module[{index},*)
(*index=-1;*)
(*Do[*)
(*(*Print[i,":\t",vect[[i]][[1]],"  ",vect[[i]][[2]]];*)*)
(*If[(vect[[i]][[1]]==lten) && (vect[[i]][[2]]==uten),index=i],*)
(*{i,1,Length[vect]}*)
(*];*)
(*If[index <0,*)
(*Print["# Error!!! Could not find component!"],*)
(*Return[index];*)
(*];*)
(*];*)


(* ::Input:: *)
(*(*findComponent[{2},{},makeVect[1,0,.5]]*)*)


(* ::Input:: *)
(*transform[T_,tensor_]:=Module[{coeff,n3s,n3bs,ten,vect,index,Tcoeff,uten,lten,llten,uuten},*)
(*ten=tensor[[1]];*)
(*{n3s,n3bs}={Dimensions[ten[[1]]][[1]],Dimensions[ten[[2]]][[1]]};*)
(*vect=makeVect[n3s,n3bs,0];*)
(*Do[*)
(*ten=tensor[[i]];*)
(*coeff=ten[[3]];*)
(*If[coeff!=0,*)
(*If[n3s>0,*)
(*uten=ten[[2]];*)
(*lten=ten[[1]];*)
(*Do[*)
(*Do[*)
(*Tcoeff=T[[lten[[u]],ii]] coeff;*)
(*llten=lten;*)
(*llten[[u]]=ii;*)
(*index=findComponent[llten,uten,vect];*)
(*vect[[index]][[3]]+=Tcoeff;*)
(*,*)
(*{ii,1,3}*)
(*]*)
(*,*)
(*{u,1,n3s}*)
(*];*)
(*];*)
(*If[n3bs>0,*)
(*uten=ten[[2]];*)
(*lten=ten[[1]];*)
(*Do[*)
(*Do[*)
(*Tcoeff=T[[ii,uten[[v]]]] coeff;*)
(*uuten=uten;*)
(*uuten[[v]]=ii;*)
(*index=findComponent[lten,uuten,vect];*)
(*vect[[index]][[3]]-=Tcoeff;*)
(*,*)
(*{ii,1,3}*)
(*]*)
(*,*)
(*{v,1,n3bs}*)
(*];*)
(*];*)
(*]*)
(*,*)
(*{i,1,Length[tensor]}*)
(*];*)
(*Return[vect];*)
(*];*)


(* ::Text:: *)
(*Projection operators*)


(* ::Input:: *)
(*P8[vect33b_]:=Module[{vv,ukvk},*)
(*ukvk=0;*)
(*vv=makeVect[1,1,0];*)
(*Do[*)
(*If[vect33b[[i]][[1]]==vect33b[[i]][[2]],*)
(*ukvk+=vect33b[[i]][[3]]*)
(*],*)
(*{i,1,Length[vect33b]}*)
(*];*)
(*Do[*)
(*vv[[i]][[3]]=vect33b[[i]][[3]];*)
(*If[vv[[i]][[1]]==vv[[i]][[2]],*)
(*vv[[i]][[3]]-=ukvk/3*)
(*],*)
(*{i,1,Length[vect33b]}*)
(*];*)
(*Return[vv];*)
(*];*)


(* ::Input:: *)
(*P1[vect33b_]:=Module[{vv,ukvk},*)
(*ukvk=0;*)
(*vv=makeVect[1,1,0];*)
(*Do[*)
(*If[vect33b[[i]][[1]]==vect33b[[i]][[2]],*)
(*ukvk+=vect33b[[i]][[3]]*)
(*],*)
(*{i,1,Length[vect33b]}*)
(*];*)
(*Do[*)
(*If[vv[[i]][[1]]==vv[[i]][[2]],*)
(*vv[[i]][[3]]+=ukvk/3*)
(*],*)
(*{i,1,Length[vect33b]}*)
(*];*)
(*Return[vv];*)
(*];*)


(* ::Input:: *)
(*P6[vect33_]:=Module[{vv,\[Epsilon],i,j,k,l,m,n},*)
(*If[Length[vect33[[1]][[1]]]==2 && Length[vect33[[1]][[2]]]==0,*)
(*vv=makeVect[2,0,0];*)
(*Do[*)
(*Do[*)
(*If[vv[[j]][[1]]=={vv[[i]][[1]][[2]],vv[[i]][[1]][[1]]},*)
(*vv[[i]][[3]]=(vect33[[i]][[3]]+vect33[[j]][[3]])/3],*)
(*{j,1,Length[vect33]}*)
(*]*)
(*,*)
(*{i,1,Length[vect33]}*)
(*];*)
(*];*)
(*If[Length[vect33[[1]][[1]]]==1 && Length[vect33[[1]][[2]]]==2,*)
(*\[Epsilon]=LeviCivitaTensor[3];*)
(*vv=makeVect[1,2,0];*)
(*Do[*)
(*{k,i,j}={vv[[ii]][[1]][[1]],vv[[ii]][[2]][[1]],vv[[ii]][[2]][[2]]};*)
(*Do[*)
(*{m,n}=vv[[jj]][[2]];*)
(*If[vv[[jj]][[1]][[1]]==k,*)
(*vv[[ii]][[3]]+=Sum[ 1/4 \[Epsilon][[i,j,l]]\[Epsilon][[l,m,n]],{l,1,3}]vect33[[jj]][[3]];*)
(*];*)
(*l=vv[[jj]][[1]][[1]];*)
(*vv[[ii]][[3]]+= 1/4 \[Epsilon][[i,j,l]]\[Epsilon][[k,m,n]]vect33[[jj]][[3]];*)
(*,*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*,*)
(*{ii,1,Length[vect33]}*)
(*];*)
(*];*)
(*Return[vv];*)
(*];*)


(* ::Input:: *)
(*P3b[vect33_]:=Module[{vv,\[Epsilon],i,j,k,l,m},*)
(*If[Length[vect33[[1]][[1]]]==2 && Length[vect33[[1]][[2]]]==0,*)
(*\[Epsilon]=LeviCivitaTensor[3];*)
(*vv=makeVect[2,0,0];*)
(*Do[*)
(*{i,j}={vv[[ii]][[1]][[1]],vv[[ii]][[1]][[2]]};*)
(*Do[*)
(*{l,m}={vv[[jj]][[1]][[1]],vv[[jj]][[1]][[2]]};*)
(*Do[*)
(*vv[[ii]][[3]]+=1/2 \[Epsilon][[i]][[j]][[k]]\[Epsilon][[k]][[l]][[m]]vect33[[jj]][[3]],*)
(*{k,1,3}*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*]*)
(*,*)
(*{ii,1,Length[vect33]}*)
(*];*)
(*];*)
(*If[Length[vect33[[1]][[1]]]==1 && Length[vect33[[1]][[2]]]==2,*)
(*vv=makeVect[1,2,0];*)
(*Do[*)
(*{k,i,j}={vv[[ii]][[1]][[1]],vv[[ii]][[2]][[1]],vv[[ii]][[2]][[2]]};*)
(*If[i==k,*)
(*Do[*)
(*If[vv[[jj]][[2]][[1]]==vv[[jj]][[1]][[1]] && vv[[jj]][[2]][[2]]==j,*)
(*vv[[ii]][[3]]+= 3/8 vect33[[jj]][[3]]*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*];*)
(*If[k==j,*)
(*Do[*)
(*If[vv[[jj]][[2]][[1]]==vv[[jj]][[1]][[1]] && vv[[jj]][[2]][[2]]==i,*)
(*vv[[ii]][[3]]-= 1/8 vect33[[jj]][[3]]*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*],*)
(*{ii,1,Length[vect33]}*)
(*];*)
(*];*)
(*Return[vv];*)
(*];*)


(* ::Input:: *)
(*(*P15[vect33_]:=Module[{vv,i,j,k,l,m,n},*)
(*If[Length[vect33[[1]][[1]]]\[Equal]1 && Length[vect33[[1]][[2]]]\[Equal]2,*)
(*vv=makeVect[1,2,0];*)
(*Do[*)
(*{k,i,j}={vv[[ii]][[1]][[1]],vv[[ii]][[2]][[1]],vv[[ii]][[2]][[2]]};*)
(*Do[*)
(*If[vv[[jj]][[1]][[1]]\[Equal]k,*)
(*If[{i,j}\[Equal]vv[[jj]][[2]],*)
(*vv[[ii]][[3]]+=1/2vect33[[jj]][[3]];*)
(*];*)
(*If[{j,i}\[Equal]vv[[jj]][[2]],*)
(*vv[[ii]][[3]]+=1/2vect33[[jj]][[3]];*)
(*];*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*If[i\[Equal]k,*)
(*Do[*)
(*If[vv[[jj]][[2]][[1]]==vv[[jj]][[1]][[1]] && vv[[jj]][[2]][[2]]\[Equal]j,*)
(*vv[[ii]][[3]]-= 1/8vect33[[jj]][[3]]*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*If[j\[Equal]k,*)
(*Do[*)
(*If[vv[[jj]][[2]][[1]]==vv[[jj]][[1]][[1]] && vv[[jj]][[2]][[2]]\[Equal]i,*)
(*vv[[ii]][[3]]-= 1/8vect33[[jj]][[3]]*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*];*)
(*],*)
(*{ii,1,Length[vect33]}*)
(*];*)
(*];*)
(*Return[vv];*)
(*];*)*)


(* ::Input:: *)
(*P0[vect33_]:=Module[{vv,i,j,k},*)
(*If[Length[vect33[[1]][[1]]]==1 && Length[vect33[[1]][[2]]]==2,*)
(*vv=makeVect[1,2,0];*)
(*Do[*)
(*{k,i,j}={vv[[ii]][[1]][[1]],vv[[ii]][[2]][[1]],vv[[ii]][[2]][[2]]};*)
(*If[k==j,*)
(*Do[*)
(*If[vv[[jj]][[1]][[1]]==vv[[jj]][[2]][[2]] && vv[[jj]][[2]][[1]]==i,*)
(*vv[[ii]][[3]]+= 1/3 vect33[[jj]][[3]]*)
(*],*)
(*{jj,1,Length[vect33]}*)
(*];*)
(*],*)
(*{ii,1,Length[vect33]}*)
(*];*)
(*];*)
(*Return[vv];*)
(*]*)


(* ::Input:: *)
(*P15[vect33_]:=diffVect[vect33,sumVect[P0[vect33],sumVect[P6[vect33],P3b[vect33]]]];*)


(* ::Section::Closed:: *)
(*testing routines *)


(* ::Subsection::Closed:: *)
(*raising/lowing operators*)


(* ::Text:: *)
(*Let's test the raising and lowering operators on the highest [3] state:*)


(* ::Input:: *)
(*highest3={{{3},{},1}};*)
(*Print["Highest state = :"]*)
(*printVect[highest3]*)
(*printVect[transform[Uplus,highest3]]*)
(*printVect[transform[Iplus,highest3]]*)
(*printVect[transform[Vplus,highest3]]*)


(* ::Text:: *)
(*All raising operators should have returned nothing.  Now let's act with lowering operators:*)


(* ::Input:: *)
(*printVect[transform[Iminus,highest3]]*)
(*printVect[transform[Uminus,highest3]]*)
(*printVect[transform[Vminus,highest3]]*)


(* ::Text:: *)
(*Let's repeat for the [3b] state:*)


(* ::Input:: *)
(*highest3b={{{},{1},1}};*)
(*Print["Highest state = :"]*)
(*printVect[highest3]*)
(*printVect[transform[Uplus,highest3b]]*)
(*printVect[transform[Iplus,highest3b]]*)
(*printVect[transform[Vplus,highest3b]]*)


(* ::Text:: *)
(*Again all raising operators should have returned nothing.  Now let's act with lowering operators:*)


(* ::Input:: *)
(*printVect[transform[Iminus,highest3b]]*)
(*printVect[transform[Uminus,highest3b]]*)
(*printVect[transform[Vminus,highest3b]]*)


(* ::Subsection::Closed:: *)
(*casimir operators*)


(* ::Text:: *)
(*Now I want to calculate Casimir operators.  Let's just look at [3] state:*)


(* ::Input:: *)
(*casimir=makeVect[1,0,0];*)
(*printVect[highest3]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],highest3]]],{ii,1,8}];*)
(*printVect[casimir]*)
(**)
(*casimir=makeVect[1,0,0];*)
(*printVect[transform[Uminus,highest3]]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],transform[Uminus,highest3]]]],{ii,1,8}];*)
(*printVect[casimir]*)
(**)
(*casimir=makeVect[1,0,0];*)
(*printVect[transform[Vminus,highest3]]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],transform[Vminus,highest3]]]],{ii,1,8}];*)
(*printVect[casimir]*)


(* ::Text:: *)
(*Let's now look at [3b] state:*)


(* ::Input:: *)
(*casimir=makeVect[0,1,0];*)
(*printVect[highest3b]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],highest3b]]],{ii,1,8}];*)
(*printVect[casimir]*)
(**)
(*casimir=makeVect[0,1,0];*)
(*printVect[transform[Iminus,highest3b]]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],transform[Iminus,highest3b]]]],{ii,1,8}];*)
(*printVect[casimir]*)
(**)
(*casimir=makeVect[0,1,0];*)
(*printVect[transform[Vminus,highest3b]]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],transform[Vminus,highest3b]]]],{ii,1,8}];*)
(*printVect[casimir]*)


(* ::Input:: *)
(*highest33b={{{1},{1},0},{{2},{1},0},{{3},{1},1},{{1},{2},0},{{2},{2},0},{{3},{2},0},{{1},{3},0},{{2},{3},0},{{3},{3},0}};*)


(* ::Input:: *)
(*casimir=makeVect[1,1,0];*)
(*printVect[highest33b]*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],highest33b]]],{ii,1,8}];*)
(*printVect[casimir]*)


(* ::Subsection:: *)
(*projection operators*)


(* ::Subsubsection:: *)
(*p[8] (q \!\(\*OverscriptBox[\(q\), \(_\)]\))*)


(* ::Text:: *)
(*Let's test the projection operators.  Now I test the projection operator for [8] (from [3] x[\!\(\*OverscriptBox[\(3\), \(_\)]\)] = [8] + [1])*)


(* ::Input:: *)
(*vec33b=makeVect[1,1,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33b;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33b;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P8[vj]],*)
(*{i,1,Length[vec33b]},{j,1,Length[vec33b]}];*)
(*vec33b=makeVect[1,1,0];*)
(*states8={};*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33b;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,1,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*AppendTo[states8,temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*ss=1;*)
(*(*ll=8;*)*)
(*printVect[states8[[ss]]]*)
(*(*Print["##"]*)
(*printVect[transform[T[ll],states3b[[ss]]]//Simplify]*)
(*Print["##"]*)*)
(*dotVect[states8[[ss]],transform[T[3],states8[[ss]]]//Simplify]//Simplify*)
(*dotVect[states8[[ss]],transform[2/Sqrt[3] T[8],states8[[ss]]]//Simplify]//Simplify*)


(* ::Subsubsection:: *)
(*p[1] (q \!\(\*OverscriptBox[\(q\), \(_\)]\))*)


(* ::Text:: *)
(*Now I test the projection operator for [1] (from [3] x[\!\(\*OverscriptBox[\(3\), \(_\)]\)] = [8] + [1])*)


(* ::Input:: *)
(*vec33b=makeVect[1,1,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33b;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33b;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P1[vj]],*)
(*{i,1,Length[vec33b]},{j,1,Length[vec33b]}];*)
(*vec33b=makeVect[1,1,0];*)
(*states1={};*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33b;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,1,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*AppendTo[states1,temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*ss=1;*)
(*(*ll=8;*)*)
(*printVect[states1[[ss]]]*)
(*(*Print["##"]*)
(*printVect[transform[T[ll],states3b[[ss]]]//Simplify]*)
(*Print["##"]*)*)
(*dotVect[states1[[ss]],transform[T[3],states1[[ss]]]//Simplify]//Simplify*)
(*dotVect[states1[[ss]],transform[2/Sqrt[3] T[8],states1[[ss]]]//Simplify]//Simplify*)


(* ::Input:: *)
(*states1[[1]]*)


(* ::Subsubsection::Closed:: *)
(*p[6] (q q)*)


(* ::Text:: *)
(*Now I test the projection operator for [6] (from [3] x[3] = [6] + [\!\(\*OverscriptBox[\(3\), \(_\)]\)])*)


(* ::Input:: *)
(*vec33=makeVect[2,0,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P6[vj]],*)
(*{i,1,Length[vec33]},{j,1,Length[vec33]}];*)
(*vec33=makeVect[2,0,0];*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,1,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Subsubsection::Closed:: *)
(*p[\!\(\*OverscriptBox[\(3\), \(_\)]\)] *)


(* ::Text:: *)
(*Now I test the projection operator for [\!\(\*OverscriptBox[\(3\), \(_\)]\)] (from [3] x [3] = [6] + [\!\(\*OverscriptBox[\(3\), \(_\)]\)])*)


(* ::Input:: *)
(*vec33=makeVect[2,0,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P3b[vj]],*)
(*{i,1,Length[vec33]},{j,1,Length[vec33]}];*)
(*vec33=makeVect[2,0,0];*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,1,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*vec33=makeVect[1,2,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P3b[vj]],*)
(*{i,1,Length[vec33]},{j,1,Length[vec33]}];*)
(*vec33=makeVect[1,2,0];*)
(*states3b={};*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,2,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*AppendTo[states3b,temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*ss=3;*)
(*(*ll=8;*)*)
(*printVect[states3b[[ss]]]*)
(*(*Print["##"]*)
(*printVect[transform[T[ll],states3b[[ss]]]//Simplify]*)
(*Print["##"]*)*)
(*dotVect[states3b[[ss]],transform[T[3],states3b[[ss]]]//Simplify]//Simplify*)
(*dotVect[states3b[[ss]],transform[2/Sqrt[3] T[8],states3b[[ss]]]//Simplify]//Simplify*)


(* ::Subsubsection::Closed:: *)
(*p[6] (q \!\(\*OverscriptBox[\(q\), \(_\)]\) \!\(\*OverscriptBox[\(q\), \(_\)]\))*)


(* ::Input:: *)
(*vec33=makeVect[1,2,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P6[vj]],*)
(*{i,1,Length[vec33]},{j,1,Length[vec33]}];*)
(*vec33=makeVect[1,2,0];*)
(*states6={};*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,2,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*AppendTo[states6,temp];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*ss=6;*)
(*(*ll=8;*)*)
(*printVect[states6[[ss]]]*)
(*(*Print["##"]*)
(*printVect[transform[T[ll],states3b[[ss]]]//Simplify]*)
(*Print["##"]*)*)
(*dotVect[states6[[ss]],transform[T[3],states6[[ss]]]//Simplify]//Simplify*)
(*dotVect[states6[[ss]],transform[2/Sqrt[3] T[8],states6[[ss]]]//Simplify]//Simplify*)


(* ::Subsubsection::Closed:: *)
(*p[15] (q \!\(\*OverscriptBox[\(q\), \(_\)]\) \!\(\*OverscriptBox[\(q\), \(_\)]\))*)


(* ::Input:: *)
(*vec33=makeVect[1,2,0];*)
(*ee=Eigensystem@Table[*)
(*vj=vec33;*)
(*vj[[j]][[3]]=1;*)
(*vi=vec33;*)
(*vi[[i]][[3]]=1;*)
(*dotVect[vi,P15[vj]],*)
(*{i,1,Length[vec33]},{j,1,Length[vec33]}];*)
(*vec33=makeVect[1,2,0];*)
(*states15={};*)
(*Do[*)
(*If[ee[[1]][[i]]!=0,*)
(*Print["\n# state ",i];*)
(*normVect=Normalize[ee[[2]][[i]]];*)
(*temp=vec33;*)
(*Do[temp[[j]][[3]]=normVect[[j]],{j,1,Length[temp]}];*)
(*casimir=makeVect[1,2,0];*)
(*Do[casimir=sumVect[casimir,transform[T[ii],transform[T[ii],temp]]],{ii,1,8}];*)
(*Print["# \!\(\*SuperscriptBox[SubscriptBox[\(T\), \(a\)], \(2\)]\) = ",dotVect[temp,casimir]//Simplify];*)
(*printVect[temp];*)
(*AppendTo[states15,temp//Simplify];*)
(*],*)
(*{i,1,Length[ee[[1]]]}*)
(*];*)


(* ::Input:: *)
(*ss=9;*)
(*(*ll=8;*)*)
(*printVect[states15[[ss]]]*)
(*(*Print["##"]*)
(*printVect[transform[T[ll],states3b[[ss]]]//Simplify]*)
(*Print["##"]*)*)
(*dotVect[states15[[ss]],transform[T[3],states15[[ss]]]//Simplify]//Simplify*)
(*dotVect[states15[[ss]],transform[2/Sqrt[3] T[8],states15[[ss]]]//Simplify]//Simplify*)


(* ::Section:: *)
(*contractions*)


(* ::Subsubsection:: *)
(*[\!\(\*OverscriptBox[\(3\), \(_\)]\)]*)


(* ::Input:: *)
(*terms={};*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]+1/8 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]] ];*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]];*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]+1/8 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,+(1/12)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]-1/12 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]];*)
(*AppendTo[terms,1/12 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]-1/12 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]] ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]];*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]]];*)
(*AppendTo[terms,-(1/6)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +1/6 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]] -1/6 ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]] -1/6 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]] +1/6 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +1/6 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,1/4 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]] -1/4 ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,1/4 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1]]] -1/4 ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,1/12 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] -1/12 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,1/12 ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] -1/12 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,-(1/24)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(1/24) ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]+1/24 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1]]]];*)
(*AppendTo[terms,-(1/24)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(1/24)ss[traceNC[GammaNC[gamma5] . propu[n1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +1/24 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(1/4)ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +1/4 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,-(1/4)ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +1/4 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,-3/8 ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]] + 3/8 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(3/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(3/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(3/8)ss[traceNC[GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,m1] . GammaNC[gamma5] . propc[m1,n1]]] +3/8 ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1]]]ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propc[m1,n1]]]];*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,+(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]] -1/8 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,-(1/8)ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)
(*AppendTo[terms,+(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]] -1/8 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]];*)


(* ::Input:: *)
(*Sum[terms[[i]],{i,1,Length[terms]}]*)
(*Length[terms]*)


(* ::Input:: *)
(*+(1/8)ss[traceNC[GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[n1,m1] . GammaNC[gamma5] . propu[m1,n1] . GammaNC[gamma5] . propc[m1,n1]]] -1/8 ss[traceNC[GammaNC[gamma5] . propu[m1,m1]]]ss[traceNC[GammaNC[gamma5] . propc[m1,n1] . GammaNC[gamma5] . propu[n1,n1] . GammaNC[gamma5] . propu[n1,m1]]]*)


(* ::Input:: *)
(*Simplify[Sqrt[1/6]*Sqrt[3/8]]*)
